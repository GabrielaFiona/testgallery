<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Endless White Gallery</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#f7f7f9; font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    canvas { display:block; width:100vw; height:100vh; }

    /* Minimal HUD */
    #hud{
      position: fixed; inset: 0;
      pointer-events:none;
    }
    .badge{
      position:absolute; left:16px; top:16px;
      padding:10px 12px; border-radius:12px;
      background: rgba(255,255,255,.75);
      border: 1px solid rgba(0,0,0,.08);
      box-shadow: 0 10px 30px rgba(0,0,0,.08);
      color:#111; font-weight:700;
      letter-spacing:.2px;
      pointer-events:none;
      backdrop-filter: blur(10px);
    }
    .hint{
      position:absolute; left:16px; top:64px;
      padding:8px 12px; border-radius:12px;
      background: rgba(255,255,255,.65);
      border: 1px solid rgba(0,0,0,.08);
      box-shadow: 0 10px 30px rgba(0,0,0,.06);
      color:#333; font-size:13px; line-height:1.35;
      max-width: 520px;
      pointer-events:none;
      backdrop-filter: blur(10px);
    }
    #reticle{
      position:absolute; left:50%; top:50%;
      transform: translate(-50%, -50%);
      width:22px; height:22px;
      display:flex; align-items:center; justify-content:center;
      color: rgba(0,0,0,.35);
      font-weight:800; font-size:18px;
      pointer-events:none;
      user-select:none;
    }

    /* Click-to-close overlay hint */
    .corner{
      position:absolute; right:16px; top:16px;
      padding:10px 12px; border-radius:12px;
      background: rgba(255,255,255,.75);
      border: 1px solid rgba(0,0,0,.08);
      box-shadow: 0 10px 30px rgba(0,0,0,.08);
      color:#111; font-weight:700;
      letter-spacing:.2px;
      opacity:.0;
      transition: opacity .18s ease;
      pointer-events:none;
      backdrop-filter: blur(10px);
    }
    .corner.show{ opacity: 1; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div id="hud">
    <div class="badge">Creative Gallery — Endless Hall</div>
    <div class="hint" id="hint">
      Drag to look • Arrow/WASD to move • Click a painting to focus • Esc to close
    </div>
    <div id="reticle">+</div>
    <div class="corner" id="closeHint">Click dim / press Esc to close</div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    const canvas = document.querySelector("#c");
    const closeHint = document.querySelector("#closeHint");

    // ---------- Renderer / Scene / Camera
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf7f7f9);
    scene.fog = new THREE.Fog(0xf7f7f9, 12, 120);

    const camera = new THREE.PerspectiveCamera(65, innerWidth / innerHeight, 0.1, 300);
    camera.position.set(0, 1.65, 6);

    // ---------- Lights (clean gallery)
    scene.add(new THREE.AmbientLight(0xffffff, 0.65));

    const key = new THREE.DirectionalLight(0xffffff, 0.55);
    key.position.set(8, 14, 8);
    scene.add(key);

    const fill = new THREE.DirectionalLight(0xffffff, 0.35);
    fill.position.set(-8, 10, -10);
    scene.add(fill);

    // ---------- Simple drag-to-look (no pointer lock)
    let yaw = 0, pitch = 0;
    const look = { dragging:false, lastX:0, lastY:0 };
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    function applyLook(){
      camera.rotation.set(pitch, yaw, 0, "YXZ");
    }

    canvas.addEventListener("pointerdown", (e) => {
      look.dragging = true;
      look.lastX = e.clientX;
      look.lastY = e.clientY;
      canvas.setPointerCapture?.(e.pointerId);
    });

    canvas.addEventListener("pointermove", (e) => {
      if (!look.dragging) return;
      const dx = e.clientX - look.lastX;
      const dy = e.clientY - look.lastY;
      look.lastX = e.clientX;
      look.lastY = e.clientY;

      yaw   -= dx * 0.003;
      pitch -= dy * 0.003;
      pitch = clamp(pitch, -1.15, 1.15);
      applyLook();
    });

    canvas.addEventListener("pointerup", () => look.dragging = false);
    canvas.addEventListener("pointercancel", () => look.dragging = false);

    // ---------- Movement (WASD + Arrow)
    const keys = { w:false,a:false,s:false,d:false, up:false,down:false,left:false,right:false, shift:false };
    addEventListener("keydown", (e) => {
      if (e.code==="KeyW") keys.w=true;
      if (e.code==="KeyA") keys.a=true;
      if (e.code==="KeyS") keys.s=true;
      if (e.code==="KeyD") keys.d=true;
      if (e.code==="ArrowUp") keys.up=true;
      if (e.code==="ArrowDown") keys.down=true;
      if (e.code==="ArrowLeft") keys.left=true;
      if (e.code==="ArrowRight") keys.right=true;
      if (e.code==="ShiftLeft"||e.code==="ShiftRight") keys.shift=true;

      if (e.code==="Escape") closeFocus();
    });
    addEventListener("keyup", (e) => {
      if (e.code==="KeyW") keys.w=false;
      if (e.code==="KeyA") keys.a=false;
      if (e.code==="KeyS") keys.s=false;
      if (e.code==="KeyD") keys.d=false;
      if (e.code==="ArrowUp") keys.up=false;
      if (e.code==="ArrowDown") keys.down=false;
      if (e.code==="ArrowLeft") keys.left=false;
      if (e.code==="ArrowRight") keys.right=false;
      if (e.code==="ShiftLeft"||e.code==="ShiftRight") keys.shift=false;
    });

    // ---------- Gallery Hall (white floor + walls)
    const hall = new THREE.Group();
    scene.add(hall);

    const floorMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.95, metalness: 0.0 });
    const wallMat  = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9,  metalness: 0.0 });
    const ceilMat  = new THREE.MeshStandardMaterial({ color: 0xfdfdff, roughness: 0.98, metalness: 0.0 });

    // A single hall "segment" that we'll repeat
    // Segment length chosen so paintings can be evenly spaced.
    const SEG_LEN = 18;
    const HALF_W = 8.5;
    const H = 5.5;

    function makeSegment(zCenter){
      const g = new THREE.Group();

      // Floor
      const floor = new THREE.Mesh(new THREE.PlaneGeometry(HALF_W*2, SEG_LEN), floorMat);
      floor.rotation.x = -Math.PI/2;
      floor.position.set(0, 0, zCenter);
      g.add(floor);

      // Ceiling
      const ceil = new THREE.Mesh(new THREE.PlaneGeometry(HALF_W*2, SEG_LEN), ceilMat);
      ceil.rotation.x = Math.PI/2;
      ceil.position.set(0, H, zCenter);
      g.add(ceil);

      // Walls
      const wallL = new THREE.Mesh(new THREE.PlaneGeometry(SEG_LEN, H), wallMat);
      wallL.rotation.y = Math.PI/2;
      wallL.position.set(-HALF_W, H/2, zCenter);
      g.add(wallL);

      const wallR = new THREE.Mesh(new THREE.PlaneGeometry(SEG_LEN, H), wallMat);
      wallR.rotation.y = -Math.PI/2;
      wallR.position.set(HALF_W, H/2, zCenter);
      g.add(wallR);

      // Soft wall base line (subtle shadow edge)
      const baseMat = new THREE.MeshStandardMaterial({ color: 0xf0f0f4, roughness: 0.95 });
      const baseL = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.08, SEG_LEN), baseMat);
      baseL.position.set(-HALF_W+0.08, 0.04, zCenter);
      g.add(baseL);

      const baseR = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.08, SEG_LEN), baseMat);
      baseR.position.set(HALF_W-0.08, 0.04, zCenter);
      g.add(baseR);

      return g;
    }

    // Repeat 5 segments; we will recycle them for an “endless” feel
    const SEG_COUNT = 5;
    const segments = [];
    for (let i = 0; i < SEG_COUNT; i++){
      const z = (i - Math.floor(SEG_COUNT/2)) * SEG_LEN;
      const seg = makeSegment(z);
      segments.push(seg);
      hall.add(seg);
    }

    // ---------- Paintings (example images you can swap)
    // Replace these later with your own URLs.
    const PAINTINGS = [
      { url: "https://picsum.photos/id/1011/1200/800", title: "Example 01" },
      { url: "https://picsum.photos/id/1025/1200/800", title: "Example 02" },
      { url: "https://picsum.photos/id/1035/1200/800", title: "Example 03" },
      { url: "https://picsum.photos/id/1043/1200/800", title: "Example 04" },
      { url: "https://picsum.photos/id/1050/1200/800", title: "Example 05" },
      { url: "https://picsum.photos/id/1062/1200/800", title: "Example 06" },
      { url: "https://picsum.photos/id/1074/1200/800", title: "Example 07" },
      { url: "https://picsum.photos/id/1084/1200/800", title: "Example 08" },
    ];

    const loader = new THREE.TextureLoader();
    const clickable = [];

    function makeFramedPainting(tex, w=3.25, h=2.15){
      const group = new THREE.Group();

      // Frame
      const frameMat = new THREE.MeshStandardMaterial({ color: 0x111114, roughness: 0.45, metalness: 0.25 });
      const frame = new THREE.Mesh(new THREE.BoxGeometry(w+0.18, h+0.18, 0.10), frameMat);
      group.add(frame);

      // Art plane
      const artMat = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.75, metalness: 0.05 });
      const art = new THREE.Mesh(new THREE.PlaneGeometry(w, h), artMat);
      art.position.z = 0.06; // sit in front of frame
      group.add(art);

      // Very subtle plaque
      const plaqueMat = new THREE.MeshStandardMaterial({ color: 0xf5f5f7, roughness: 0.9 });
      const plaque = new THREE.Mesh(new THREE.BoxGeometry(w*0.45, 0.08, 0.02), plaqueMat);
      plaque.position.set(0, -h/2 - 0.14, 0.02);
      group.add(plaque);

      return { group, art };
    }

    // Place paintings down the corridor on both sides
    const PAINT_SPACING = 6.0;
    const START_Z = 18; // near front
    const END_Z   = -80; // deep into hall (they’ll recycle)

    let paintIndex = 0;
    for (let z = START_Z; z >= END_Z; z -= PAINT_SPACING){
      for (const side of [-1, 1]){
        const p = PAINTINGS[paintIndex % PAINTINGS.length];
        const tex = loader.load(p.url);
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.anisotropy = 8;

        const { group, art } = makeFramedPainting(tex);

        const x = side * (HALF_W - 0.9);
        const y = 2.25;
        group.position.set(x, y, z);

        // Face inward
        group.rotation.y = side === -1 ? Math.PI/2 : -Math.PI/2;

        // store metadata on the ART mesh for raycasting
        art.userData = { title: p.title, url: p.url, side, z0: z };
        clickable.push(art);

        // Add a tiny spotlight above each piece (still clean, just “gallery”)
        const spot = new THREE.SpotLight(0xffffff, 0.8, 10, Math.PI/6, 0.65, 1.0);
        spot.position.set(x + (side * 0.8), y + 1.7, z + 0.7);
        spot.target.position.set(x, y, z);
        hall.add(spot);
        hall.add(spot.target);

        hall.add(group);

        paintIndex++;
      }
    }

    // ---------- Endless illusion recycling
    // We recycle hall segments behind/ahead of the camera as you move.
    function recycleSegments(){
      // Determine which segment is farthest ahead and farthest behind in Z
      let minZ = Infinity, maxZ = -Infinity;
      let minSeg = null, maxSeg = null;

      for (const seg of segments){
        // Each segment centered at seg children positions; just use first child as reference
        const z = seg.children[0].position.z;
        if (z < minZ){ minZ = z; minSeg = seg; }
        if (z > maxZ){ maxZ = z; maxSeg = seg; }
      }

      // If camera moved far beyond the “front” of segments, move the farthest-behind segment forward
      // We’re moving along -Z, so "ahead" is more negative Z.
      const camZ = camera.position.z;

      // if camera is close to minZ (deep), push the max segment behind to further deep
      if (camZ - minZ < 10){
        // move the farthest-forward segment (maxZ) behind the farthest-behind (minZ)
        const newZ = minZ - SEG_LEN;
        for (const child of maxSeg.children){
          child.position.z = newZ;
        }
      }

      // if camera is too close to maxZ (back), pull the min segment forward
      if (maxZ - camZ < 10){
        const newZ = maxZ + SEG_LEN;
        for (const child of minSeg.children){
          child.position.z = newZ;
        }
      }
    }

    // ---------- Click-to-focus feature artwork (center framed)
    // We create an overlay group that appears in front of camera, centered.
    const overlay = new THREE.Group();
    scene.add(overlay);

    // dim background plane (click to close)
    const dimMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.0 });
    const dimPlane = new THREE.Mesh(new THREE.PlaneGeometry(50, 50), dimMat);
    dimPlane.position.set(0, 0, -3);
    dimPlane.userData = { isDim: true };
    overlay.add(dimPlane);

    // Featured frame + art plane (starts invisible)
    const featuredGroup = new THREE.Group();
    overlay.add(featuredGroup);
    featuredGroup.visible = false;

    const featFrameMat = new THREE.MeshStandardMaterial({ color: 0x111114, roughness: 0.4, metalness: 0.25 });
    const featFrame = new THREE.Mesh(new THREE.BoxGeometry(6.6, 4.4, 0.16), featFrameMat);
    featuredGroup.add(featFrame);

    const featTex = new THREE.Texture();
    const featArtMat = new THREE.MeshStandardMaterial({ map: featTex, roughness: 0.75, metalness: 0.05 });
    const featArt = new THREE.Mesh(new THREE.PlaneGeometry(6.3, 4.1), featArtMat);
    featArt.position.z = 0.10;
    featuredGroup.add(featArt);

    const featLight = new THREE.SpotLight(0xffffff, 0.9, 30, Math.PI/5, 0.7, 1.0);
    featLight.position.set(0, 3.2, 1.8);
    featLight.target.position.set(0, 0.2, -3);
    overlay.add(featLight);
    overlay.add(featLight.target);

    // Keep overlay in front of camera
    function updateOverlay(){
      // position overlay at camera, oriented with camera
      overlay.position.copy(camera.position);
      overlay.quaternion.copy(camera.quaternion);

      // keep featured art a bit forward and centered
      featuredGroup.position.set(0, 0.1, -3.2);
      dimPlane.position.set(0, 0.0, -3.4);
    }

    let isFocused = false;
    function openFocusFromUrl(url){
      const tex = loader.load(url, () => {
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.anisotropy = 8;
        featArtMat.map = tex;
        featArtMat.needsUpdate = true;
      });

      featuredGroup.visible = true;
      isFocused = true;
      closeHint.classList.add("show");

      // dim in
      dimMat.opacity = 0.22;
      // subtle zoom pop animation values
      featuredGroup.scale.set(0.96, 0.96, 0.96);
      focusTween = { t0: performance.now(), dur: 220 };
    }

    function closeFocus(){
      if (!isFocused) return;
      isFocused = false;
      closeHint.classList.remove("show");
      // dim out
      dimMat.opacity = 0.0;
      featuredGroup.visible = false;
    }

    // ---------- Raycasting
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function setMouseFromEvent(e){
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);
    }

    canvas.addEventListener("click", (e) => {
      setMouseFromEvent(e);
      raycaster.setFromCamera(mouse, camera);

      // If focused, allow clicking dimPlane to close
      if (isFocused){
        const hits = raycaster.intersectObject(dimPlane, false);
        if (hits.length){
          closeFocus();
          return;
        }
      }

      // Normal: click paintings to focus
      const hits = raycaster.intersectObjects(clickable, false);
      if (hits.length){
        const art = hits[0].object;
        openFocusFromUrl(art.userData.url);
      }
    });

    // ---------- Movement update + simple turn keys
    function move(dt){
      if (isFocused) return; // freeze movement while focused (feels more elegant)

      const speed = (keys.shift ? 7.0 : 4.4);
      const turnSpeed = 1.65;

      if (keys.left)  yaw += turnSpeed * dt;
      if (keys.right) yaw -= turnSpeed * dt;
      applyLook();

      const forward = (keys.w || keys.up) ? 1 : 0;
      const back    = (keys.s || keys.down) ? 1 : 0;
      const strL     = keys.a ? 1 : 0;
      const strR     = keys.d ? 1 : 0;

      const dz = (forward - back) * speed * dt;
      const dx = (strR - strL) * speed * dt;

      // move relative to yaw
      const forwardVec = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)).multiplyScalar(-dz);
      const rightVec   = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw)).multiplyScalar(dx);

      camera.position.add(forwardVec).add(rightVec);

      // Keep within hallway width (so it reads like a corridor)
      camera.position.x = THREE.MathUtils.clamp(camera.position.x, -2.3, 2.3);
      camera.position.y = 1.65;
    }

    // ---------- Small “pop” tween for focused art
    let focusTween = null;
    function tickFocusTween(now){
      if (!focusTween) return;
      const t = (now - focusTween.t0) / focusTween.dur;
      if (t >= 1){
        featuredGroup.scale.set(1,1,1);
        focusTween = null;
        return;
      }
      const k = 1 - Math.pow(1 - t, 3); // easeOutCubic
      const s = 0.96 + (1.0 - 0.96) * k;
      featuredGroup.scale.set(s, s, s);
    }

    // ---------- Animate
    let last = performance.now();
    function animate(now){
      requestAnimationFrame(animate);
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;

      move(dt);
      recycleSegments();
      updateOverlay();
      tickFocusTween(now);

      renderer.render(scene, camera);
    }
    animate(performance.now());

    addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
